---
title: "Validation of contig-cluster approach"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{contig-clusters}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(dplyr.summarise.inform = FALSE)
```

## Introduction and Methods

Reviewers of the manuscript asked for more detail on the contig cluster analysis. This is provided below; two additional analyses are provided. First, I explore the stability of the clusters to changing the parameters of the clustering algorithm. The clusters were originally defined using cd-hit with no length cutoff, and a sequence identity of 0.95 (with kmer length 10); in this sensitivity analysis, the length cutoff (of smaller sequences relative to the largest in the cluster) was varied from 0 to 0.8 in steps of 0.2 (with sequence identity held at 0.95), and sequence identity of the smaller sequences to the cluster representative was varied from 0.95 to 1 in steps of 0.01.

The effect of these changes was assessed in two ways: first, by plotting cumulative cluster membership: that is, ordering clusters from largest to smallest along the x axis, and plotting the cumulative proportion of samples that are clustered as the number of clusters increases. Secondly, by plotting network graphs of clusters. In these plots, points are clusters with point size determined by cluster size. As length or sequence identifty cutoff is changed, the clusters fragment, so the points become smaller. Points containing the same samples are linked by lines, showing how clusters fragment. The graphs are plotted as directed acyclic graphs: in each case, the original clusters are at the top of the page and then the clusters with higher length or sequence identity cutoff are sequentially below.

The second analysis consists of generating multiple sequence alignments of the clusters themselves, then visualising them with the sequence coverage of the cluster representative sample, along with measures of sequence diversity. Multiple sequence alignments were generated by mapping the contigs to the cluster representative sequence with minimap2 v2.16 and the -asm5 presets. SAM files were used to generate a multiple sequence alignment then  nucleotide diversity at each position calculated using PopGenome v2.7.5 in R. 

Alignments were plotted from the generated PAF files with coverage of the reference sequence indicated by colour and whether the sequence is mapped on the forward (+) or reverse (-) strand. Secondary alignments are shown with
dashed outlines. Plots are in order of cluster size from largest to smallest.

```{r setup}
library(blantyreESBL)
library(igraph)
library(ggraph)
library(tidygraph)
library(dplyr)
library(ggplot2)
library(stringr)
library(forcats)
library(purrr)

write_figs <- FALSE


if (write_figs) {
  if (!dir.exists(here("figures"))) {dir.create(here("figures"))}
  if (!dir.exists(here("tables"))) {dir.create(here("tables"))}
  
  if (!dir.exists(here("figures/long-modelling"))) {
    dir.create(here("figures/long-modelling"))
  }
  
  if (!dir.exists(here("tables/long-modelling"))) {
    dir.create(here("tables/long-modelling"))
    }
}

```

## Results

### Varying length and sequence identity cutoff in clsutering algorithm

#### Cumulative cluster membership plots

Clusters are stable to increasing length cutoff, and increasing sequence identity - up to 100%, when the clusters fragment.


```{r plot-cum-membership, fig.height = 6, fig.width = 9, fig.cap = "Cumulative proportion of samples that are included in a cluster as a function of number of clusters, stratified by ESBL gene. CLusters are ordered on the x-axis from smallest to largest. Number of samples in which a given ESBL geen was found is shown in the panel header. The coloured lines show the effect of varying the sequence length cutoff in the clustering algorithm." }

# function to restrict axes to integers
int_breaks_rounded <- function(x, n = 5)  {
  pretty(x, n)[round(pretty(x, n),1) %% 1 == 0]
}

# cluster cumulative membership: varying length cutoff ----------------

btESBL_contigclusters_sensax %>%
  filter(ident_cutoff == 0.95) %>%
  transmute(
    id = gsub("^\\.", "", contig),
    clstr = as.character(cluster),
    gene = gsub("_", "", gene),
    len_diff_cutoff = len_diff_cutoff,
    ident_cutoff = ident_cutoff
  ) %>%
  mutate(clstr = paste0(
    clstr,
    "_",
    gsub("_", "", gene),
    "_l",
    len_diff_cutoff,
    "_i",
    ident_cutoff
  )) %>%
  bind_rows(
    btESBL_contigclusters %>%
      transmute(
        id = id,
        gene = gsub("_", "", gene),
        len_diff_cutoff = 0,
        ident_cutoff = 0.95,
        clstr = paste0(
          str_extract(clstr_name, "(?<=\\.)[0-9]*$"),
          "_",
          str_extract(clstr_name, ".*(?=\\.)"),
          "_l",
          len_diff_cutoff,
          "_i",
          ident_cutoff
        )
      )
  ) %>%
  group_by(len_diff_cutoff, gene) %>%
  mutate(
    n_gene = n()
  ) %>%
  group_by(gene) %>%
  mutate(
    gene = paste0(gene, " (n = ", max(n_gene), ")")
  ) %>%
  ungroup() %>%
  mutate(
    gene = fct_rev(fct_reorder(gene, n_gene, .fun = max))
  ) %>%
  group_by(len_diff_cutoff, clstr, gene) %>%
  summarise(n = n()) %>%
  arrange(gene, len_diff_cutoff, -n) %>%
  group_by(gene, len_diff_cutoff) %>%
  mutate(n_clust = 1:n()) %>%
  mutate(
    prop = cumsum(n) / sum(n)
  ) %>%
  # addd skanky (0,0) start
  group_by(gene, len_diff_cutoff, ) %>%
  arrange(gene, len_diff_cutoff, n_clust) %>%
  do(add_row(., .before = 1, prop = 0, n_clust = 0)) %>%
  ungroup() %>%
  do(tidyr::fill(., c(len_diff_cutoff, gene), .direction = "up")) %>%
  ggplot(aes(n_clust,
    prop,
    group = len_diff_cutoff,
    color = len_diff_cutoff
  )) +
  geom_step() +
  facet_wrap(~gene, scales = "free_x") +
  labs(
    x = "Number of clusters",
    y = "Cumulative number of samples",
    color = "CD-HIT\nlength cutoff"
  ) +
  theme_bw() +
  scale_x_continuous(breaks = int_breaks_rounded) -> len_plot

len_plot

if (write_figs) {
  ggsave(here("figures/long-modelling/SUP_FIG_contig_sensax_lenplot.pdf"),
         len_plot,width = 9, height = 6)
  ggsave(here("figures/long-modelling/SUP_FIG_contig_sensax_lenplot.svg"),
         len_plot,width = 9, height = 6)
}

```

```{r plot-cum-membership2, fig.height = 6, fig.width = 9, fig.cap = "Cumulative proportion of samples that are included in a cluster as a function of number of clusters, stratified by ESBL gene. CLusters are ordered on the x-axis from smallest to largest. Number of samples in which a given ESBL geen was found is shown in the panel header. The coloured lines show the effect of varying the sequence identity cutoff in the clustering algorithm." }


btESBL_contigclusters_sensax %>%
  filter(len_diff_cutoff == 0) %>%
  transmute(
    id = gsub("^\\.", "", contig),
    clstr = as.character(cluster),
    gene = gsub("_", "", gene),
    len_diff_cutoff = len_diff_cutoff,
    ident_cutoff = ident_cutoff
  ) %>%
  mutate(clstr = paste0(
    clstr,
    "_",
    gsub("_", "", gene),
    "_l",
    len_diff_cutoff,
    "_i",
    ident_cutoff
  )) %>%
  bind_rows(
    btESBL_contigclusters %>%
      transmute(
        id = id,
        gene = gsub("_", "", gene),
        len_diff_cutoff = 0,
        ident_cutoff = 0.95,
        clstr = paste0(
          str_extract(clstr_name, "(?<=\\.)[0-9]*$"),
          "_",
          str_extract(clstr_name, ".*(?=\\.)"),
          "_l",
          len_diff_cutoff,
          "_i",
          ident_cutoff
        )
      )
  ) %>%
  group_by(ident_cutoff, gene) %>%
  mutate(
    n_gene = n()
  ) %>%
  group_by(gene) %>%
  mutate(
    gene = paste0(gene, " (n = ", max(n_gene), ")")
  ) %>%
  ungroup() %>%
  mutate(
    gene = fct_infreq(gene)
  ) %>%
  group_by(ident_cutoff, clstr, gene) %>%
  summarise(n = n()) %>%
  arrange(gene, ident_cutoff, -n) %>%
  group_by(gene, ident_cutoff) %>%
  mutate(n_clust = 1:n()) %>%
  mutate(
    prop = cumsum(n) / sum(n)
  ) %>%
  # addd skanky (0,0) start
  group_by(gene, ident_cutoff, ) %>%
  arrange(gene, ident_cutoff, n_clust) %>%
  do(add_row(., .before = 1, prop = 0, n_clust = 0)) %>%
  ungroup() %>%
  do(tidyr::fill(., c(ident_cutoff, gene), .direction = "up")) %>%
  ggplot(aes(n_clust,
    prop,
    group = ident_cutoff,
    color = ident_cutoff
  )) +
  geom_step() +
  facet_wrap(~gene, scales = "free_x") +
  labs(
    x = "Number of clusters",
    y = "Cumulative number of samples",
    color = "CD-HIT\nidentity cutoff"
  ) +
  theme_bw() +
  scale_x_continuous(breaks = int_breaks_rounded) -> ident_plot

ident_plot

if (write_figs) {
  ggsave(here("figures/long-modelling/SUP_FIG_contig_sensax_identplot.pdf"),
         ident_plot,width = 9, height = 6)
  ggsave(here("figures/long-modelling/SUP_FIG_contig_sensax_identplot.svg"),
         ident_plot_plot,width = 9, height = 6)
}

```

#### Directed acyclic graphs of cluster membership


```{r plotting-functions}

# plotting functions ----------------------
return_cluster_plot_df <-
  function(sample_cluster_df, gene_to_plot, cluster_cutoff,
           len_cutoff_vec = c(0, 0.2, 0.4, 0.6, 0.8),
           ident_cutoff_vec = c(0.95, 0.95, 0.95, 0.95, 0.95)) {
    if (length(len_cutoff_vec) != length(ident_cutoff_vec)) {
      stop("Different vector lengths in return_cluster_plot_df")
    }
    if (length(len_cutoff_vec) < 2) {
      stop("Need at least 2 len_ and ident_ cutoff values")
    }

    # assume a data frame with
    # id = cntig id
    # clstre = cluster id
    # gene = gene
    # len_dfiff_cutoff
    # idnet_cutoff
    # l
    # This will plot 5 layers - a is top, defined by the len and ident_cutoffs
    # provided; b next, -> c , etc
    # clsuter_cutoff will plot only clusters in row a of size >= cluster cutoff
    # the len_cut
    # the strategy:
    # 1) make a df of each unique set of len and  ident_cutoffs
    # 2) left join df a to df b by sample id - the clusters in dfa become
    # clst.x and the clsuters in dfb become clst.y.
    # 3) group by clust.x and xlust y and tally
    # 4) Add in other dfs in same way

    dfa <-
      sample_cluster_df %>%
      filter(
        gene == gene_to_plot,
        len_diff_cutoff == len_cutoff_vec[1],
        ident_cutoff == ident_cutoff_vec[1]
      )

    dfb <- sample_cluster_df %>%
      dplyr::filter(
        gene == gene_to_plot,
        len_diff_cutoff == len_cutoff_vec[2],
        ident_cutoff == ident_cutoff_vec[2]
      )

    left_join(
      dfa %>%
        select(id, clstr) %>%
        group_by(clstr) %>%
        mutate(clst.size = n()) %>%
        filter(clst.size >= cluster_cutoff),
      dfb %>%
        select(id, clstr) %>%
        group_by(clstr) %>%
        mutate(clst.size = n()),
      by = "id"
    ) %>%
      group_by(clstr.x, clst.size.x, clstr.y, clst.size.y) %>%
      tally() %>%
      transmute(
        from_clst_size = clst.size.x,
        from = clstr.x,
        to_clst_size = clst.size.y,
        to = clstr.y,
        n = n
      ) ->
    edges

    bind_rows(
      dfa %>%
        filter(clstr %in% edges$from),
      dfb %>%
        filter(clstr %in% edges$to)
    ) %>%
      group_by(
        clstr, len_diff_cutoff,
        ident_cutoff
      ) %>%
      summarise(size = n()) -> nodes

    if (length(len_cutoff_vec) > 2) {
      for (i in 3:length(len_cutoff_vec)) {
        sample_cluster_df %>%
          filter(
            len_diff_cutoff == len_cutoff_vec[i],
            ident_cutoff == ident_cutoff_vec[i],
            gene == gene_to_plot
          ) -> dfc
        add_next_edge_layer(edges, dfb, dfc) -> newedges
        add_new_nodes(newedges, dfc) -> newnodes
        nodes <- bind_rows(nodes, newnodes)
        edges <- bind_rows(edges, newedges)
        dfb <- dfc
      }
    }

    tbl_graph(
      nodes = nodes,
      edges = edges,
      directed = TRUE
    ) -> out_graph_df
    return(out_graph_df)
  }

add_next_edge_layer <- function(edges, dfb, dfc) {
  left_join(
    dfb %>%
      filter(clstr %in% edges$to) %>%
      select(id, clstr) %>%
      group_by(clstr) %>%
      mutate(clst.size = n()),
    dfc %>%
      select(id, clstr) %>%
      group_by(clstr) %>%
      mutate(clst.size = n()),
    by = "id"
  ) %>%
    group_by(clstr.x, clst.size.x, clstr.y, clst.size.y) %>%
    tally() %>%
    transmute(
      from_clst_size = clst.size.x,
      from = clstr.x,
      to_clst_size = clst.size.y,
      to = clstr.y,
      n = n
    ) ->
  edges_new

  return(edges_new)
}

add_new_nodes <- function(edges, dfc) {
  dfc %>%
    filter(clstr %in% edges$to) %>%
    group_by(clstr, len_diff_cutoff, ident_cutoff) %>%
    summarise(size = n()) -> nodes_new
  return(nodes_new)
}

min_cluster_size_picker <-  function(df, gene , cutoff = 20, size = 5, len = 0, seq = 0.95) {
 df %>%  
    filter(gene == {{gene}},
           len_diff_cutoff == len,
           ident_cutoff == seq) -> df
 
    if (length(unique(df$clstr)) > cutoff) {
      returnval <- size
    } else {
      returnval <- 1
  }
  
  
return(returnval)
}

```


```{r prepare-plot-clsuters}

### prepare data -----------------------------------------

btESBL_contigclusters_sensax %>%
  transmute(
    id = gsub("^\\.", "", contig),
    clstr = as.character(cluster),
    gene = gsub("_", "", gene),
    len_diff_cutoff = len_diff_cutoff,
    ident_cutoff = ident_cutoff
  ) %>%
  mutate(clstr = paste0(
    clstr,
    "_",
    gsub("_", "", gene),
    "_l",
    len_diff_cutoff,
    "_i",
    ident_cutoff
  )) %>%
  bind_rows(
    btESBL_contigclusters %>%
      transmute(
        id = gsub("^\\.", "", id),
        gene = gsub("_", "", gene),
        len_diff_cutoff = 0,
        ident_cutoff = 0.95,
        clstr = paste0(
          str_extract(clstr_name, "(?<=\\.)[0-9]*$"),
          "_",
          str_extract(clstr_name, ".*(?=\\.)"),
          "_l",
          len_diff_cutoff,
          "_i",
          ident_cutoff
        )
      )
  ) -> sample_cluster_df


genes <- sample_cluster_df %>% 
  group_by(gene) %>% 
  tally() %>% 
  arrange(desc(n)) %>% 
  pull(gene)

purrr::map(genes,
    ~ return_cluster_plot_df(
      sample_cluster_df, .x, 
      min_cluster_size_picker(sample_cluster_df,.x,20,5),
      len_cutoff_vec = c(0,0,0,0,0),
      ident_cutoff_vec = c(0.95, 0.97, 0.98, 0.99, 1.00)) %>% 
      ggraph(layout = "sugiyama") +
      geom_edge_link(aes(edge_width = n), alpha = 0.7, show.legend = FALSE) +
      geom_node_point(aes(size = size, color = as.factor(ident_cutoff))) +
      labs(color = "CD-HIT\nsequence\nidentity", 
        size = "Cluster\nsize",
        title = .x,
        subtitle = 
          if_else(
            min_cluster_size_picker(sample_cluster_df,.x,20,5) > 1,
            paste0("Restricted to clusters of at least ", 
              min_cluster_size_picker(sample_cluster_df,.x,20,5), 
              " samples"),
            "All clusters shown")) +
      scale_color_viridis_d() +
      theme_void() 
) -> seq_ident_dag_plots

purrr::map(genes,
    ~ return_cluster_plot_df(
      sample_cluster_df, .x, 
      min_cluster_size_picker(sample_cluster_df,.x,20,5),
      len_cutoff_vec = c(0,0.2,0.4,0.6,0.8),
      ident_cutoff_vec = c(0.95, 0.95, 0.95, 0.95, 0.95)) %>% 
      ggraph(layout = "sugiyama") +
      geom_edge_link(aes(edge_width = n), alpha = 0.7, show.legend = FALSE) +
      geom_node_point(aes(size = size, color = as.factor(len_diff_cutoff))) +
      labs(color = "CD-HIT\nlength\ncutoff", 
        size = "Cluster\nsize",
         subtitle = 
          if_else(
            min_cluster_size_picker(sample_cluster_df,.x,20,5) > 1,
            paste0("Restricted to clusters of at least ", 
              min_cluster_size_picker(sample_cluster_df,.x,20,5), 
              " samples"),
            "All clusters shown"),
        title = .x) +
      scale_color_viridis_d() +
      theme_void() 
) -> len_cutoff_dag_plots


```


##### Varying sequence identity

```{r plot-seq-ident, fig.width = 6, fig.height = 4}

for (i in 1:length(seq_ident_dag_plots)) {
  print(seq_ident_dag_plots[[i]])
        }


```

##### Varying length cutoff

```{r plot-len-cutoff, fig.width = 6, fig.height = 4}

for (i in 1:length(len_cutoff_dag_plots)) {
  print(len_cutoff_dag_plots[[i]])
        }


```
